\documentclass[letterpaper,12pt,oneside]{article}

\usepackage[top=1in, left=1.25in, right=1.25in, bottom=1in]{geometry}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[spanish,es-nodecimaldot,es-tabla]{babel}
\usepackage{caption, subcaption}
\usepackage{graphicx}
\usepackage{array}
\usepackage{tikz}
\usepackage{imakeidx}
\usepackage[style=numeric]{biblatex}
\usepackage{csquotes}
\usepackage{placeins}
\usepackage{float}
\usepackage{setspace}

\addbibresource{./bib/protocolo.bib}
\graphicspath{./figs/}

\begin{document}
\begin{titlepage}
    \centering
    \includegraphics[width=1\textwidth]{Carátula reportes POO.pdf}
\end{titlepage}

\tableofcontents
\clearpage 

\section{Introducción} %Este apartado debe abordar los siguientes puntos:

\begin{itemize}
    \item \textbf{Planteamiento del problema:}\\ %Se hace una descripción del problema a resolver.
    Desarrollar una aplicación que simule el sistema de batallas de Pokémon. La aplicación debe gestionar un combate por turnos entre usuario y rival, determinando el orden de ataque con base en la velocidad y finalizando el encuentro cuando la salud de alguno llegue a cero. Asimismo, el sistema debe implementar la lógica de efectividad de tipos de acuerdo con la tabla de tipos y ofrecer una interfaz gráfica interactiva que permita seleccionar ataques y visualizar el estado actual del combate.
    \item \textbf{Motivación:}\\ %Se describe por qué es necesario dar solución al problema.
    La simulación de un sistema de batalla por turnos representa un escenario ideal para la implementación avanzada de POO, ya que requiere la interacción constante entre múltiples objetos con estados complejos. Utilizar Flutter permite aplicar lógica de backend y comprender cómo los objetos se vinculan con una interfaz gráfica reactiva, usando el patrón de diseño MVC y acercando el desarrollo a un entorno de producción de software moderno y funcional.
    \item \textbf{Objetivos:}\\ %Lo que se espera obtener al darle solución al problema.
    Implementar una jerarquía de clases que modele correctamente las entidades del juego aplicando conceptos fundamentales como herencia, polimorfismo, clases abstractas y el patrón de diseño MVC, así como integrar la lógica con la interfaz de usuario mediante el manejo de estados en Flutter, asegurando que las reglas del juego se ejecuten de manera consistente y transparente para el usuario.
\end{itemize}

\section{Marco Teórico}


\subsection{Dart}
Dart es un lenguaje de programación moderno, desarrollado por Google, que combina el poder de la programación orientada a objetos con la facilidad y eficiencia de los lenguajes de programación basados en scripts [1].

\subsection{Clases y Objetos}
Una clase es una plantilla que define atributos y comportamientos, mientras que un objeto es una instancia concreta de dicha clase. En Dart, las clases permiten representar entidades del sistema como Pokémon o ataques, y facilitan la modularidad del código [2].

\subsection{Herencia y Clases Abstractas}
Son los mecanismos que permiten crear jerarquías donde una clase base define
comportamientos comunes que son extendidos y concretados por subclases específicas.
Esto facilita la reutilización de código y el polimorfismo [3].

\subsection{Polimorfismo}
El polimorfismo permite que un mismo método pueda tener comportamientos diferentes dependiendo del objeto que lo invoque. En el sistema de batalla, ataques de distintos tipos pueden sobrescribir métodos para calcular daño de forma específica.

\subsection{Encapsulamiento}
Consiste en ocultar los detalles internos de una clase y exponer solo lo necesario mediante métodos públicos. Esto permite gestionar de forma segura atributos como puntos de salud (HP) o velocidad, evitando modificaciones no controladas.

\subsection{Constructores y Parámetros Nombrados}
Los constructores permiten inicializar objetos y, con los parámetros nombrados, Dart facilita la legibilidad y claridad al crear entidades complejas como ataques o Pokémon con múltiples atributos.

\subsection{Colecciones y Listas}
Dart proporciona listas dinámicas que permiten almacenar colecciones de objetos, como los movimientos de un Pokémon.

\subsection{Manejo de Estados y Lógica de Negocio}
La lógica de turnos, aplicación de daño, cambios de estado y verificación de condiciones de victoria se implementan mediante métodos dentro de las clases del sistema. El uso de estructuras condicionales y funciones permite controlar cada etapa del combate.

\subsection{Uso de la Biblioteca \texttt{dart:math}}
Se emplea para generar valores aleatorios en ataques, o variaciones en el daño, mediante la clase \texttt{Random}.

\subsection{Flutter}
Flutter es un \textit{framework} basado en widgets, componentes visuales inmutables que describen la estructura de la interfaz. Cada pantalla o elemento gráfico (selección de ataques, barra de vida, menús) se construye con widgets [4].

\textbf{Stateful Widgets.}
Se utilizan cuando la interfaz debe reaccionar a cambios en el estado interno, como la actualización del HP o el avance del combate por turnos.

\textbf{Gestión de Estado.}
El método \texttt{setState()} permite actualizar variables y reflejar cambios en la interfaz. Esto es fundamental para mostrar en tiempo real la vida restante, los mensajes de combate o la disponibilidad de acciones.

\subsection{Mecánicas de Combate Pokémon}

\textbf{HP (Health Points):}
``Es la condición física del Pokémon, representada con un valor
numérico. Estos son reducidos normalmente mediante los ataques del oponente
en combate, los efectos del veneno, las quemaduras, o varios climas entre otros
medios'' [5].

\textbf{Velocidad:}
``La velocidad es la propiedad del Pokémon de atacar, antes o después,
que el oponente. A la hora de atacar el Pokémon con un mayor valor de velocidad,
por lo general, siempre atacará primero''.

\textbf{Efectividad por Tipos.}
Cada tipo de ataque puede ser más o menos efectivo dependiendo del tipo del oponente.
Esta efectividad se expresa como multiplicadores: neutral (1), supereficaz (2), poco eficaz (0.5) o sin efecto (0) [6].
\begin{figure} [H]
    \centering
    \includegraphics[width=0.75\linewidth]{PROYECTO-03//Reporte//Borradores/TablaTipos.png}
    \caption{Tabla de tipos de Pokémon. [6]}
\end{figure}

\subsection{Patrones de Diseño}

\textbf{Modelo–Vista–Controlador (MVC).}
El patrón MVC separa la lógica de negocio (modelo), la interfaz de usuario (vista) y el flujo de datos (controlador). En Flutter, esta separación se logra mediante la distribución de clases y widgets, permitiendo un proyecto organizado, escalable y sostenible [7].

\section{Desarrollo} %Es la descripción de la implementación realizada en el lenguaje de programación, así como las pruebas realizadas para obtener los resultados. No se debe mostrar código, solo describir funciones o la aplicación de los conceptos teóricos. Las pruebas es describir las entradas ingresadas y las salidas obtenidas.

La aplicación dentro del paquete \texttt{mx.unam.fi.poo.p910} permite la ejecución de un programa que simula un juego de batalla Pokemón donde se aplicaron los conceptos principales de programación orientada a objetos tales como herencia, polimorfismo, manejo de errores y el patrón de diseño \texttt{MVC}. A continuación de explica a detalle el funcionamiento de cada parte del código.

\subsection{Main}
Es el punto de partida del progama, importa la librería \texttt{material} para el uso de widgets y \texttt{seleccion\_page} de \texttt{paginas} siendo la primera pagina que se mostrará en la ejecución, poniendo como widget raíz a \texttt{MartialApp}.

\subsection{Modelo}
En el modelo se encapsula la información de la aplicación y se define la lógica con la que se manipulan los datos, por lo que en esta capa se definieron los siguientes archivos:

\subsubsection{Pokemon}
Se define la clase \textbf{Pokemon} con los atributos básicos que heredan los pokemon de todos los tipos, siendo estos: nombre, nivel, tipo, imagen, velocidad, vida, su lista de ataques y se define un generador aleatorio \texttt{Random} para asignar diferentes valores de velocidad y vida a cada pokemon, haciendo al juego más dinámico variando los valores de las estadísticas de los Pokemon. Finalmente se genera una lista \texttt{listaPokemones} que genera un pokemon de cada tipo siendo los pokemon que estarán disponibles dentro de la aplicación.

\subsubsection{Ataques}
Se genera la clase \textbf{Ataque} que incluye los atributos de nombre, tipo y potencia, siendo generadas posteriormente clases hijas que que definen el tipo de ataque, así se crean listas que contengas 3 ataques de un tipo en específico permitiendo asignar movimientos coherentes a los pokemon de la clase \textbf{Pokemon}.

\subsection{Vista}
El objetivo de los objetos defindos en la capa de vista es mostrar la información del objeto del modelo y habilitar la edición de información enviando la información al controlador, es así que en esta capa se controla el cómo se muestra la información al usuairo creando la clase abstracta \textbf{CombateView} en la que sus métodos señalan los mensajes que deben mostrase cuando ocurra una batalla, tales como \texttt{mostrarSuperEfectivo()}, \texttt{mostrarPocoEfectivo()}, \texttt{mostrarNoAfecta()}, etc. 

Los métodos son definidos en la clase \textbf{FLutterCombateView} donde todos lo métodos se apoyan en \texttt{\_append} que usa \texttt{notifyListeners()} y un atributo \texttt{log} para guardar el texto de lo que ocurre en el combate.
0
\subsection{Controlador}
El controlador hace de intermediaro entre la capa del modelo y la capa de la vista, por lo que esta capa se encarga de decidir los efectos de las acciones en el combate y comunicárselo a la vista. Para esto se define un map \textbf{tablaTipos} donde una clave es el tipo de ataque y la otra el tipo del defensor tomando como valor un multiplicador que se define para el daño que un pokemón le puede causar a otro dependiendo del tipo de ambos. Este map es usado en la funcion \textbf{\_atacar()} para calcular el daño multiplicando el multiplicador por la potencia del ataque, mostrando el daño hecho y el mensaje definido en \texttt{view} sobre la efectividad del ataque.

\subsubsection{CombateController}
La clase \textbf{CombateController} coordina la secuencia de los turnos con ayuda del método \texttt{iniciarTurnoFlutter()} que verifica la vida de los dos jugadores y en base al atributo de velocidad ordena los turnos, haciendo uso de la función \texttt{\_atacar()} y de los mensajes definidos en \texttt{combate\_view}.

\subsection{Páginas}
En esta carpeta se precisan las dos páginas que se mostrarán en la aplicación, siendo la de selección de pokemones y la combate, detallando cada una a continuación.

\subsubsection{batalla\_page}
Esta clase implementa la pantalla que visualiza el usuario en el sistema de combate de la aplicación por lo que gestiona la interfaz gráfica y la interacción con el usuari, para esto la clase se extiende de StatefulWidget ya que la interfaz cambia con el tiempo, se definen los pokemones.\\

Se crea un método \texttt{initState()} que crea el controlador del combate y la vista de la batalla, añadiendo un metodo escucha para \texttt{flutterView} que notifica a setState en caso de algún cambio para bajar el scrollbar hasta el final. Empleando también una función \texttt{\_reproducirMusica} que usa un try/cath y un \texttt{async} para reproducir una canción cuando se abra la página.\\

Para la interfaz se declara el método \texttt{\_getIconoTipo()} que recibe un tipo de pokemon y devuelve un tipo de icono a usar. Posteriormente se declara un método \texttt{ejecutarTurno()} que llama al controlador de combate para procesar el turno una vez que el usuario ha usado un ataque.

Con respecto a los widwets usados para la interfaz se tienen los siguientes:
\begin{itemize}
    \item build()\\
    Es el método responsable de generar la pantalla de batalla, para organizar la estrucutra de la pantalla se utiliza un \texttt{Scaffold} , una \texttt{appBar} que señala la batalla pokemon, el registro de la batalla contenido dentro de \texttt{SingleChildScrollView} y un \texttt{bottomNavigationBar} que alterna entre los botones principales y los de ataque en la parte ingerior de la pantalla.
    \item buildPokemonInfo()\\
    El método contruye la tarjeta en la que se muestra la información del pokemón usado y el rival, tornando la vida de rojo cuando es menor a los 500 puntos de vida y organizando la información a través de \texttt{Row} para mostrar la información del rival del lado derecho y la del pokemon propio del lado izquiero.
    \item imagenPokemon()\\
    El método se encarga de mostrar la visualización de la imagen del pokemon, decidiendo su tamaño, utilizando SizedBox y mostrando una equis de color opaco cuando los puntos de vida del pokemon sean menores a 0.
    \item retroButton()\\
    El método encapsula el estilo de creación de botones, recibiendo el texto y la función que hará el botón.
    \item buildBotonesPrincipales()\\
    El método revisa la vida de los pokemon, siendo el caso que si los dos siguen con vida se da la opción de huir o luchar, y en caso de que el pokemon propio haya muerto solo se da la opción de ir hacia atrás, generando la página de selección.
    \item buildBottomBar()\\
    El método construye una barra inferior que muestra los ataques cuando la variable \texttt{mostrarAtaques} es verdadera, es decir se ha presionado el botón de Lucha, de lo contrario se muestran los botones principales.
    \item buildBarraAtaques()\\
    El método construye la barra donde se muestran los ataques diponibles del pokemon, utilizando el método del botón retro para ejecutar los ataques.
    \item buildListaAtaques()
    El método construye la lista completa de ataques del pokémon del jugador cuando se elige la opción Lucha. Para organizar su contenido, utiliza un Row y muestra cada ataque como un elemento independiente lo que ejecuta el ataque mediante ejecutarTurno().
\end{itemize}

\subsubsection{seleccion\_page}
Es una clase definida como un StatefulWidget, es el punto de entrada a la interacción
lógica del usuario y se encarga de gestionar el flujo de elección de los combatientes antes
de iniciar la batalla.\\

Se construyó mediante un Scaffold que aloja un GridView.builder, el cual renderiza la
colección de objetos Pokemon disponibles en la lista del modelo. Cada celda de la rejilla
encapsula la información del Pokémon (imagen, nombre y tipo) dentro de un widget Card,
para una presentación organizada y uniforme.\\

La lógica de selección se implementó mediante el manejo de estado interno de la clase.
Se declaró un atributo nullable Pokemon? jugadorSeleccionado, el cual determina el
comportamiento del evento onTap detectado por el GestureDetector. El funcionamiento se
divide en dos fases: en la primera, si el atributo es nulo, el objeto seleccionado se asigna al
usuario y se invoca a setState() para actualizar la interfaz, cambiando el color de la tarjeta
a verde para indicarle al usuario que el Pokémon fue seleccionado, además, la barra
superior modifica su título según la fase de selección en la que se encuentre el usuario.\\

Después, la transición hacia el combate se gestiona en la segunda fase de interacción. Al
detectar una segunda selección, la clase instancia la navegación mediante el método
Navigator.push, aquí es donde se crea la BatallaPage, inicializándola con las referencias
tanto del objeto jugadorFinal como del rivalFinal.

\subsection*{Diagrama de clases (UML estático)}

\begin{figure} [H]
    \centering
    \includegraphics[width=1\linewidth]{PROYECTO-03/Reporte/Borradores/estatica1.png}
    \caption{UML Estático: Diagrama de clases de Pokemon.}
\end{figure}

\begin{figure} [H]
    \centering
    \includegraphics[width=1\linewidth]{PROYECTO-03/Reporte/Borradores/estatica2.png}
    \caption{UML Estático: Diagrama de clases de Ataque.}
\end{figure}

\begin{figure} [H]
    \centering
    \includegraphics[width=1\linewidth]{PROYECTO-03/Reporte/Borradores/estatica3.png}
    \caption{UML Estático: Diagrama de clases de main.}
\end{figure}
   
\subsection*{Diagrama de secuencia (UML dinámico)}
\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{PROYECTO-03/Reporte/Borradores/UML dinamico_ diagrama de secuencia_main.png}
    \caption{UML Dinámico: Diagrama de secuencia del main.}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{PROYECTO-03/Reporte/Borradores/UML dinamico_ diagrama de secuencia_combate_view.png}
    \caption{UML Dinámico: Diagrama de secuencia de combate view.}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\linewidth]{PROYECTO-03/Reporte/Borradores/UML dinamico_ diagrama de secuencia_combate_controller.png}
    \caption{UML Dinámico: Diagrama de secuencia de combate controller.}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{PROYECTO-03/Reporte/Borradores/UML dinamico_ diagrama de secuencia_seleccion_page.png}
    \caption{UML Dinámico: Diagrama de secuencia de seleccion page.}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{PROYECTO-03/Reporte/Borradores/UML dinamico_ diagrama de secuencia_batalla_page.png}
    \caption{UML Dinámico: Diagrama de secuencia de batalla page.}
\end{figure}

\section{Resultados} %Mediante capturas de pantalla y una breve descripción seguida de la captura se presentan los resultados finales de su aplicación.
\begin{figure} [H]
    \centering
    \includegraphics[width=0.8\linewidth]{PROYECTO-03/Reporte/Borradores/Eleccion.png}
    \caption{Pantalla inicial donde se escoge el Pokémon del usuario y el Pokémon rival.}
\end{figure}
\begin{figure} [H]
    \centering
    \includegraphics[width=0.8\linewidth]{PROYECTO-03/Reporte/Borradores/Batalla1.png}
    \caption{Pantalla de batalla inicial; batalla de exhibición.}
\end{figure}
\begin{figure} [H]
    \centering
    \includegraphics[width=0.8\linewidth]{PROYECTO-03/Reporte/Borradores/Ataques.png}
    \caption{Pantalla de batalla, menú de ataques (mostrando solo los ataques disponibles del Pokémon elegido).}
\end{figure}
\begin{figure} [H]
    \centering
    \includegraphics[width=0.5\linewidth]{PROYECTO-03/Reporte/Borradores/Logbatalla.png}
    \caption{Pantalla de batalla, historial de batalla que muestra los movimientos realizados por ambos pokemones.}
\end{figure}
\begin{figure} [H]
    \centering
    \includegraphics[width=0.8\linewidth]{PROYECTO-03/Reporte/Borradores/Batalla2.png}
    \caption{Pantalla de batalla, fin de la batalla con los resultados correspondientes.}
\end{figure}

\section{Conclusiones}
El desarrollo de este proyecto permitió integrar de manera efectiva el paradigma de la Programación Orientada a Objetos con la lógica de desarrollo de aplicaciones en Flutter. Se comprobó que el uso de clases abstractas y herencia es esencial para gestionar la diversidad de los elementos de un programa sin duplicar código, permitiendo que el sistema sea escalable y sostenible.

La implementación de la tabla de tipos y el cálculo de daño evidenció la importancia de centralizar las reglas en valores finales para evitar inconsistencias en el estado de la batalla. Además, la gestión de turnos basada en la velocidad reforzó la comprensión del flujo de control y la manipulación de objetos en tiempo de ejecución. Finalmente, el uso de Flutter y el patrón de diseño MVC demostró cómo la programación orientada a objetos sirve como base sólida para construir interfaces gráficas dinámicas, donde cada elemento visual responde a los cambios en los modelos de datos.
section*{Referencias}
\begin{thebibliography}{9}

\bibitem{dart}
Google. \textbf{A Tour of the Dart Language}. URL: \url{https://dart.dev/language}

\bibitem{dartClasses}
Dart Language Documentation. \textbf{Classes}. Nov. 2025. URL: \url{https://dart.dev/language/classes}

\bibitem{dartExtend}
Dart Language Documentation. \textbf{Object-Oriented Programming in Dart}. Nov. 2025. URL: \url{https://dart.dev/language/extend}

\bibitem{flutterArch}
Flutter Documentation. \textbf{Architectural Overview}. Dic. 2025. URL: \url{https://docs.flutter.dev/resources/architectural-overview}

\bibitem{pokeStats}
Wikidex. \textbf{Mecánica - Características}. Nov. 2025. URL: \url{https://www.wikidex.net/wiki/Caracter%C3%ADsticas}

\bibitem{pokeTypes}
Wikidex. \textbf{Mecánica - Tipos}. Nov. 2025. URL: \url{https://www.wikidex.net/wiki/Tipo#Efectividades_de_los_tipos}

\bibitem{mvc}
Rhm, F. (2023). \textbf{Understanding MVC Architecture in Flutter: A Comprehensive Guide with Examples}. Medium. URL: \url{https://medium.com/@Faiz_Rhm/understanding-mvc-architecture-in-flutter-a-comprehensive-guide-with-examples-5d1a372c7eaf}
\end{thebibliography}
\end{document}

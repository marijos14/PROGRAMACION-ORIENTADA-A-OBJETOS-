\documentclass[letterpaper,12pt,oneside]{article}

\usepackage[top=1in, left=1.25in, right=1.25in, bottom=1in]{geometry}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[spanish,es-nodecimaldot,es-tabla]{babel}
\usepackage{caption, subcaption}
\usepackage{graphicx}
\usepackage{array}
\usepackage{tikz}
\usepackage{imakeidx}
\usepackage[style=numeric]{biblatex}
\usepackage{csquotes}
\usepackage{placeins}
\usepackage{float}
\usepackage{setspace}

\addbibresource{./bib/protocolo.bib}
\graphicspath{./figs/}

\begin{document}
\begin{titlepage}
    \centering
    \includegraphics[width=1\textwidth]{Carátula reportes POO.pdf}
\end{titlepage}

\tableofcontents
\clearpage

\section{Introducción} %Este apartado debe abordar los siguientes puntos:

\begin{itemize}
    \item \textbf{Planteamiento del problema:}\\ %Se hace una descripción del problema a resolver.
    Analizar el código proporcionado para identificar y explicar la aplicación práctica de los temas de Archivos, Hilos y Patrones de Diseño en los diferentes ejemplos. Además de documentar la arquitectura estática y dinámica de los programas mediante Diagramas UML y dar la interpretación de los conceptos teóricos en el contexto del código.
    \item \textbf{Motivación:}\\ %Se describe por qué es necesario dar solución al problema.
    La combinación de la persistencia de datos (Archivos), la gestión de tareas concurrentes (Hilos) y las soluciones arquitectónicas comprobadas (Patrones de Diseño) es fundamental en el desarrollo de software complejo. Esta práctica permite integrar conocimientos avanzados de POO, fortaleciendo la capacidad de construir aplicaciones robustas, eficientes y sostenibles, que pueden gestionar recursos y ejecutar tareas de manera óptima.
    \item \textbf{Objetivos:}\\ %Lo que se espera obtener al darle solución al problema.
    Aplicar los conceptos de manejo de archivos para la persistencia de información y ejecutar procesos concurrentes mediante hilos para mejorar la eficiencia del sistema, así como identificar y modelar los patrones de diseño implementados en el código proporcionado. Además, reforzar la habilidad de documentar la arquitectura del software mediante la creación de Diagramas UML estáticos y dinámicos.
\end{itemize}

\section{Marco Teórico}
 \subsection{Archivos}
En Dart, la manipulación del sistema de archivos se gestiona principalmente a través de la librería \texttt{dart:io}. Esta librería provee clases como \texttt{File} y \texttt{Directory} para interactuar con el sistema operativo.

\subsection{Asincronía en I/O}
Un concepto crítico en Dart es que las operaciones de Entrada/Salida (I/O) deben ser, preferentemente, \textbf{no bloqueantes}. Dado que Dart es \textit{single-threaded} en su ejecución principal, leer un archivo grande de manera síncrona congelaría la interfaz de usuario.
\begin{itemize}
    \item \textbf{Síncrono:} \texttt{file.readAsStringSync()} (Bloquea el hilo).
    \item \textbf{Asíncrono:} \texttt{file.readAsString()} (Retorna un \texttt{Future}).
\end{itemize}

El uso de las palabras reservadas \texttt{async} y \texttt{await} permite escribir código asíncrono que se lee como si fuera síncrono, facilitando el manejo de excepciones y el flujo lógico.

\section{Hilos y Concurrencia (Isolates)}
A diferencia de Java, donde se crean múltiples \textit{Threads} que comparten el mismo espacio de memoria, Dart utiliza un modelo de aislamiento basado en el \textbf{Event Loop} y los \textbf{Isolates}.

\subsection{El Event Loop vs. Threads}
Dart ejecuta el código en un único hilo principal impulsado por un bucle de eventos (\textit{Event Loop}). Para tareas concurrentes ligeras (como esperar una respuesta HTTP o leer un archivo), no se crean nuevos hilos del sistema operativo; simplemente se programan en el Event Loop.

\subsection{Isolates}
Cuando se requiere procesamiento pesado (CPU-bound) que podría bloquear el Event Loop, Dart utiliza \textbf{Isolates}.
\begin{itemize}
    \item Cada Isolate tiene su propio espacio de memoria (Heap).
    \item \textbf{No hay memoria compartida:} Esto elimina la necesidad de \textit{locks} complejos y evita condiciones de carrera (\textit{race conditions}).
    \item La comunicación entre el hilo principal y un Isolate se realiza mediante paso de mensajes (\textit{message passing}) a través de puertos (\textit{Ports}).
\end{itemize}


\section{Patrones de Diseño en Dart}
La sintaxis moderna de Dart permite implementar los patrones del \textit{Gang of Four} (GoF) de manera más concisa, e incluso algunos están integrados en el lenguaje.

\subsection{Patrón Singleton}
El patrón Singleton asegura que una clase tenga una única instancia. En Dart, esto se logra elegantemente utilizando un constructor privado y un \textit{factory constructor}.

\begin{itemize}
    \item Instancia estática privada
    \item Constructor privado
    \item Factory constructor retorna la instancia existente
\end{itemize}

\subsection{Patrón Observer (Streams)}
Mientras que en otros lenguajes se implementan interfaces \texttt{Observer} y \texttt{Subject} manualmente, Dart incorpora este patrón de forma nativa a través de los \textbf{Streams}.
\begin{itemize}
    \item \textbf{StreamController:} Actúa como el sujeto que emite eventos.
    \item \textbf{StreamSubscription:} Actúa como el observador que escucha los cambios.
\end{itemize}
Este mecanismo es la base de la arquitectura reactiva (BLoC, Provider) utilizada comúnmente en Flutter.

\section{Desarrollo} %Es la descripción de la implementación realizada en el lenguaje de programación, así como las pruebas realizadas para obtener los resultados. No se debe mostrar código, solo describir funciones o la aplicación de los conceptos teóricos. Las pruebas es describir las entradas ingresadas y las salidas obtenidas.

\subsection{Código del tema Archivos}
La aplicación desarrollada permite la creación, lectura y sobreescritura de archivos tipo \texttt{.txt} implementando los conceptos de manejo de errores y archivos, pues el programa implementa \textbf{dart.io} para la entrada/ salida de datos y basa su funcionamiento en el flujo de datos que se produce entre el porograma y la fuente. Explicando más a fondo la aplicación:

\subsubsection{main()}
Es la clase principal en la que se imprime un menú con las e opciones disponibles para trabajar con archivos de texto. Cada opción a excepción de la de salir en la que solo se muestra un mensaje, llama un función de tipo privada para realizar la operación en cuestión, ofreciendo así un código más organizado.

\subsubsection{Funciones:}
\subsubsection*{crearYEscribirArchivo()}
La función tiene el propósito de crear un archivo de tipo \texttt{.txt} y permitirle al usuario ingresar el contenido, donde el contenido admitido solo son Strings. Una vez que se confirma que el nombre del archvio no es \texttt{NULL} o vacío, utiliza una lista de Strings para agregar las lineas escritas y termina una vez que detecta que se escribión \texttt{FIN}.\\

Las líneas escritas en la lista son agregadas a un archivo \textbf{FILE} donde se implementa manejo de errores al poner el bloque de código dentro de un try/catch para cubrir el caso en el que ocurra un error al guardar el archivo.

\subsubsection*{leerArchivoExistente()}
La función tiene el propósito de leer el contenido de un archivo que se busca a través de una ruta proporcionada por el usuario, una vez que se comprueba que la ruta es válida se implementa un \texttt{try} para comprobar la existencia del archivo con \texttt{existsSync()}. Si el archivo existe, el contenido se lee como cadena y se imrpime en consola.

\subsubsection*{sobrescribirArchvio()}
La función tiene el propósito de buscar un archivo a través de una ruta proporcionada por el usuario, donde se verifica la validez de la ruta y la existencia del archivo que se está buscando. Se lanza un mensajde de confirmación para la sobreescritura del archivo, en caso de ingresar \texttt{SI} se continua con la sobreescritura, guardando las nuevas líneas de texto en la lista \texttt{nuevasLineas[]}, cuando se detecte la palabra \texttt{FIN} se implementa un \texttt{try/catch} para ingresar el nuevo texto al archivo, mandando un mensaje de error en caso de que falle la operación,

\subsection{Ejemplos del tema Hilos}

\subsubsection{Ejemplo 1:}
El primer ejemplo es de concurrencua básica donde se utilizan \textbf{Future} para marcar una tarea que se completará a futuro sin interfenir con el hilo principal y \textbf{async} para marcar que la tarea es asíncrona. Así la tarea Inicio se completa y espera dos segundos a que la tarea \texttt{Future.deloyed} terminé su ejecución, imprimiendo los mensajes en consola como si hubiera sido una sola tarea que se ejecutó en secuencia. 

\subsubsection{EJemplo 2:}
Se usa \textbf{Future} y \textbf{async} para señalar que la función es asíncrona y que puede ejecutar tareas que requieran tiempo de espera además de la opción de utilizar \textbf{await} trabajando con la concurrencia. Así funciona imprimiendo un mensaje inicial, pero el \texttt{await} señala que el programa podrá continuar una vez que espere el resultado de \texttt{Future.deloyed}, finalizando en un tiempo de 2 segundos.

\subsubsection{Ejemplo 3:}
El tercer ejemplo muestra un caso básico de uso de \textbf{Isolate} usando la comunicación por mensajes. Así se crea una función \texttt{tarea} donde se define el método \texttt{SendPort} utilizado para mandar mensajes al isolate principal. Por otro lado el isolate principal define el método escucha \texttt{receivePort} para recibir el mensaje y usa \texttt{async} para usar \texttt{await} haciendo que el programa espere a que se cree un nuevo isolate donde se ejecute el método tarea indicando con \texttt{receivePort.sendPort} lo que va a recibir, extrayendo el mensaje con el método escucha \texttt{receivePort.listen()} y por último imprimiendo el mensaje en pantalla y cerrando el \textbf{receivePort} ya que no hay necesidad de recibir mensajes.

\subsubsection{Ejemplo 4:}
El cuarto ejemplo consiste en realizar la suma de cero a cinco millones sin bloquear el hilo principal, implementando los isolates para hacer la operación pesada de manera independiente sin interrumpir el flujo del isolate principal. Así se crea la función \texttt{sumaGrande()} que define su método \textbf{sendPort}. Por otra parte el isolate principal define su método escucha \textbf{receive} y usa \textbf{await} para seguir el flujo una vez que se cree el isolate paralelo y ejecute la operación mientras el flujo del isolate principal se prepara para recibir el resultado, imprimiendolo una vez que el hilo paralelo acaba la sumatoria.

\subsubsection{Ejemplo 5:}
En este ejemplo se implementa una comunicación bidireccional entre dos isolates, uno se encarga de mandar y otro de recibir, para lo cual ambos deben definir sus métodos \textbf{receivePort} y \textbf{sendPort}. Así la función worker define sus métodos y a través del método escucha \texttt{receive.listen()} recibe los mensajes del main y manda una respuesta con \texttt{mainPort.send()}. Por otra parte el \texttt{main()} crea un isolate donde se ejecuta worker y así recibe su \texttt{sendPort()} creando su método escucha y definiendo un if/else para confirmar cuando se establezca la comunicación obteniendo como primer mensaje el \texttt{sendPort} y como segundo mensaje la respuesta de \texttt{worker}, matando el isolate al finalizar para devolver el control al sistema.

\subsubsection{Ejemplo 6:}
Este último ejemplo muestra el caso de ejecución del ejemplo 4 donde se realiza la sumatoria, pero ahora realizando todo en un solo hilo mostrando que al final el tiempo de ejecución es despreciable, pero recordando que la utildiad de los hilos está en la eficiencia de la ejecución y la optimización de recursos.

\subsection{Patrones de diseño}
La implementación se estructuró siguiendo el patrón de arquitectura Modelo-Vista-Controlador, organizando el código en tres capas principales.

\subsubsection{Capa de modelo (Clases Pokemon y Ataque)}
La clase Pokemon modela las características base de los pokemonen, posee atributos finales como nombre, nivel y tipo, además de atributos calculados dinámicamente como vida y velocidad. En el constructor, se utiliza la clase Random para asignar valores aleatorios a estas estadísticas basándose en el nivel del pokemon. Se implementaron las subclases PokemonFuego y PokemonHierba, las cuales heredan de Pokemon e inicializan el tipo específico mediante la llamada al constructor de la superclase con el método super.\\

De manera análoga, la clase Ataque define la estructura de los movimientos con atributos para nombre, tipo y potencia. Se extendió esta funcionalidad a través de las clases AtaqueFuego, AtaqueHierba y AtaqueNormal, permitiendo clasificar las acciones para el combate.

\subsubsection{Capa de vista (Clases CombateView)}
Se definió una clase abstracta CombateView, que establece los métodos necesarios para la interacción con el usuario, tales como mostrarInformacionPokemon, mostrarDanio o mostrarGanador. La implementación concreta se realizó en la clase ConsoleCombateView, la cual define el comportamiento de estos métodos utilizando la función print para desplegar los eventos y resultados del combate directamente en la consola.

\subsubsection{Capa de controlador (Clase CombateController)}
La clase CombateController es quien gestiona el flujo del programa. Cuenta con un atributo de tipo CombateView para comunicarse con la interfaz. Su lógica central reside en el método iniciarCombate, el cual recibe a los pokemones y gestiona el combate dentro de un ciclo while que se mantiene activo mientras la vida de ambos pokemones sea mayor a cero.\\

Dentro de este ciclo, se determina el orden de los turnos comparando el atributo velocidad de cada pokemon, en caso de empate, se utiliza Random para decidir aleatoriamente quién ataca primero. El cálculo del daño se realiza con el método privado \_atacar, donde se evalúa la efectividad de tipos verificando si el tipo del ataque tiene ventaja contra el tipo del defensor, asignando un multiplicador de 2.0 para ataques ``súper efectivos'' o de 0.5 para ``poco efectivos''. Finalmente, se actualiza el estado del defensor y se notifica a la vista.

\subsubsection{Método principal (Main)}
En la función main se realiza la instanciación e inicialización de los componentes. Se crea primero la vista ConsoleCombateView y se usa en el constructor del CombateController. Posteriormente, se instancian los objetos de tipo PokemonFuego y PokemonHierba con sus nombres y niveles, así como un objeto de tipo Ataque. Finalmente, se invoca el método iniciarCombate del controlador, pasando los objetos creados como argumentos para dar inicio a la ejecución del programa.

\subsection*{Diagrama de clases (UML estático)}
%Se presenta un diagrama de clases que modela la aplicacion de forma estática
\begin{figure} [H]
    \centering
    \includegraphics[width=0.50\linewidth]{PRACTICA-111213/Reporte/Borradores/estatica1de11.png}
    \caption{UML:Diagrama de estado del tema 11.}
\end{figure}
\begin{figure} [H]
    \centering
    \includegraphics[width=1\linewidth]{PRACTICA-111213/Reporte/Borradores/estatica12de12.png}
    \caption{UML:Diagrama de estado del ejemplo 1 y 2 del tema 11.}
\end{figure}
\begin{figure} [H]
    \centering
    \includegraphics[width=0.50\linewidth]{PRACTICA-111213/Reporte/Borradores/estatica3de12.png}
    \caption{UML:Diagrama de estado del ejemplo 3 del tema 12.}
\end{figure}
\begin{figure} [H]
    \centering
    \includegraphics[width=0.50\linewidth]{PRACTICA-111213/Reporte/Borradores/estatica4de12.png}
    \caption{UML:Diagrama de estado del ejemplo 4 del tema 12.}
\end{figure}
\begin{figure} [H]
    \centering
    \includegraphics[width=0.50\linewidth]{PRACTICA-111213/Reporte/Borradores/estatica5de12.png}
    \caption{UML:Diagrama de estado del ejemplo 5 del tema 12.}
\end{figure}
\begin{figure} [H]
    \centering
    \includegraphics[width=0.50\linewidth]{PRACTICA-111213/Reporte/Borradores/estatica6de12.png}
    \caption{UML:Diagrama de estado del ejemplo 6 del tema 12.}
\end{figure}
\begin{figure} [H]
    \centering
    \includegraphics[width=1\linewidth]{PRACTICA-111213/Reporte/Borradores/estatica1de13.png}
    \caption{UML:Diagrama de estado de pokemon tema 13.}
\end{figure}
\begin{figure} [H]
    \centering
    \includegraphics[width=1\linewidth]{PRACTICA-111213/Reporte/Borradores/estatica2de13.png}
    \caption{UML:Diagrama de estado de ataques tema 13.}
\end{figure}
\begin{figure} [H]
    \centering
    \includegraphics[width=0.50\linewidth]{PRACTICA-111213/Reporte/Borradores/estatica3de13.png}
    \caption{UML:Diagrama de estado de comabte tema 13.}
\end{figure}
\begin{figure} [H]
    \centering
    \includegraphics[width=0.50\linewidth]{PRACTICA-111213/Reporte/Borradores/estatica4de13.png}
    \caption{UML:Diagrama de estado entrenador tema 13.}
\end{figure}

\subsection*{Diagrama de secuencia (UML dinámico)}
%Se presenta un diagrama de secuencia que modela la aplicacion de forma dinamica
\vspace{-0.3cm} % ← reduce espacio antes de la figura

\begin{figure} [H]
    \centering
    \includegraphics[width=1\linewidth]{PRACTICA-111213/Reporte/Borradores/Diagrama de secuencia (Dinamico)_Ejemplo 2.png}
    \caption{Diagrama de Secuencia: Ejemplo 2}
\end{figure}


\begin{figure} [H]
    \centering
    \includegraphics[width=1\linewidth]{PRACTICA-111213/Reporte/Borradores/Diagrama de secuencia (Dinamico)_Ejemplo 4.png}
    \caption{Diagrama de Secuencia: Ejemplo 4}
\end{figure}


\begin{figure} [H]
    \centering
    \includegraphics[width=.95\linewidth]{PRACTICA-111213/Reporte/Borradores/Diagrama de secuencia (Dinamico)_Ejemplo 5.png}
    \caption{Diagrama de Secuencia: Ejemplo 5}
\end{figure}

\vspace{0.5cm}

\section{Resultados} %Mediante capturas de pantalla y una breve descripción seguida de la captura se presentan los resultados finales de su aplicación.
\subsection*{Archivos}
\begin{figure} [H]
    \centering
    \includegraphics[width=0.6\linewidth]{PRACTICA-111213/Reporte/Borradores/Archivos1.png}
    \caption{Creando un archivo de ejemplo y escribiendo texto en él.}
\end{figure}
\begin{figure} [H]
    \centering
    \includegraphics[width=0.6\linewidth]{PRACTICA-111213/Reporte/Borradores/Archivos2.png}
    \caption{Leyendo el archivo creado.}
\end{figure}
\begin{figure} [H]
    \centering
    \includegraphics[width=0.6\linewidth]{PRACTICA-111213/Reporte/Borradores/Archivos3.png}
    \caption{Sobrescribiendo el archivo creado y leyéndolo nuevamente para corroborar el resultado.}
\end{figure}
\subsection*{Hilos}
Implementación donde se busca demostrar los procesos independientes de los hilos al ejecutar el programa.
\begin{figure} [H]
    \centering
    \includegraphics[width=0.45\linewidth]{PRACTICA-111213/Reporte/Borradores/Hilos1.png}
    \caption{Salida del ejemplo 1.}
\end{figure}
Implementación donde se ejemplifica la ejecución de hilos de manera secuencial (uno espera al otro).
\begin{figure} [H]
    \centering
    \includegraphics[width=0.45\linewidth]{PRACTICA-111213/Reporte/Borradores/Hilos2.png}
    \caption{Salida del ejemplo 2.}
\end{figure}
Ejemplo básico de comunicación entre hilos.
\begin{figure} [H]
    \centering
    \includegraphics[width=0.45\linewidth]{PRACTICA-111213/Reporte/Borradores/Hilos3.png}
    \caption{Salida del ejemplo 3.}
\end{figure}
Implementación donde se aprecia la repartición de tareas hacia cada hilo.
\begin{figure} [H]
    \centering
    \includegraphics[width=0.6\linewidth]{PRACTICA-111213/Reporte/Borradores/Hilos4.png}
    \caption{Salida del ejemplo 4.}
\end{figure}
Ejemplo de comunicación y paso de mensajes entre los hilos y su interacción con el método principal.
\begin{figure} [H]
    \centering
    \includegraphics[width=0.7\linewidth]{PRACTICA-111213/Reporte/Borradores/Hilos5.png}
    \caption{Salida del ejemplo 5.}
\end{figure}
Implementación de resolución del problema del ejemplo 4 de manera secuencial, con el objetivo de comparar tiempos de ejecución y consumo de recursos.
\begin{figure} [H]
    \centering
    \includegraphics[width=0.45\linewidth]{PRACTICA-111213/Reporte/Borradores/Hilos6.png}
    \caption{Salida del ejemplo 6.}
\end{figure}
\subsection*{Patrones de diseño}
\begin{figure} [H]
    \centering
    \includegraphics[width=0.7\linewidth]{PRACTICA-111213/Reporte/Borradores/Patrones1.png}
    \caption{Ejecución del programa con pokemones de prueba.}
\end{figure}

\section{Conclusiones} %Se presenta un análisis de los resultados obtenidos, donde se destaca la importancia de la aplicación de los conceptos teóricos para resolver el problema. No es describir si les gustó la actividad o no. No es decir qué se obtuvo de la práctica. No es describir lo que fue difícil.
La identificación de las clases y métodos de entrada/salida de datos evidenció la correcta implementación del manejo de archivos, permitiendo al sistema la persistencia de la información.\\
El análisis de los ejemplos de concurrencia facilitó la comprensión de la gestión de hilos, mostrando cómo se estructuran las tareas para un procesamiento eficiente y simultáneo.\\
Además, la interpretación de los patrones de diseño presentes en la arquitectura del código mostró la importancia de utilizar soluciones ya establecidas para garantizar un diseño extensible y sostenible. La elaboración de los Diagramas UML complementó el proceso, reforzando la habilidad de modelar y documentar sistemas de software complejos y confirmando la comprensión de los conceptos requeridos en esta práctica.

\printbibliography 
\begin{thebibliography}{9}

\bibitem{dart}
Google Developers,
\textit{Dart Language Tour}.
Disponible en: \url{https://dart.dev/language}
[Consultado: 26-nov-2025].

\bibitem{uml}
M. Fowler,
\textit{UML Distilled: A Brief Guide to the Standard Object Modeling Language},
3rd ed., Addison-Wesley, 2003.

\bibitem{exception}
D. van der Linden,
\textit{Effective Dart: Usage}.
Disponible en: \url{https://dart.dev/guides/language/effective-dart/usage}
[Consultado: 26-nov-2025].

\end{thebibliography}

\end{document}